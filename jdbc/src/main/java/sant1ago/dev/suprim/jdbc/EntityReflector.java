package sant1ago.dev.suprim.jdbc;

import org.postgresql.util.PGobject;
import sant1ago.dev.suprim.annotation.entity.Column;
import sant1ago.dev.suprim.annotation.entity.Entity;
import sant1ago.dev.suprim.annotation.entity.Id;
import sant1ago.dev.suprim.annotation.entity.JsonbColumn;
import sant1ago.dev.suprim.annotation.entity.Table;
import sant1ago.dev.suprim.annotation.type.GenerationType;
import sant1ago.dev.suprim.annotation.type.IdGenerator;
import sant1ago.dev.suprim.annotation.type.SqlType;
import sant1ago.dev.suprim.casey.Casey;
import tools.jackson.databind.ObjectMapper;

import java.lang.reflect.Field;
import java.sql.SQLException;
import java.util.*;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Utility for entity reflection operations.
 * Extracts IDs, sets field values, and converts entities to column maps.
 * Uses caching for performance.
 *
 * <p>Uses {@link ReflectionUtils} for safe field access with public getter/setter preference.
 */
final class EntityReflector {

    private static final Map<Class<?>, Field> ID_FIELD_CACHE = new ConcurrentHashMap<>();
    private static final Map<Class<?>, Map<String, Field>> FIELD_CACHE = new ConcurrentHashMap<>();
    private static final Map<Class<?>, EntityMeta> ENTITY_META_CACHE = new ConcurrentHashMap<>();
    private static final Map<Class<?>, IdMeta> ID_META_CACHE = new ConcurrentHashMap<>();
    private static final ObjectMapper JSON_MAPPER = new ObjectMapper();

    /**
     * Cached entity metadata (table name, schema, ID column).
     */
    record EntityMeta(String tableName, String schema, String idColumn) {}

    /**
     * Cached ID field metadata for generation strategy.
     *
     * @param fieldName Java field name
     * @param columnName database column name
     * @param fieldType Java type of the ID field
     * @param strategy generation strategy from @Id annotation
     * @param generatorClass custom generator class (or IdGenerator.None.class)
     * @param sequenceName sequence name for SEQUENCE strategy
     */
    record IdMeta(
        String fieldName,
        String columnName,
        Class<?> fieldType,
        GenerationType strategy,
        Class<? extends IdGenerator<?>> generatorClass,
        String sequenceName,
        SqlType columnType
    ) {
        /**
         * Check if ID is generated by application before insert.
         */
        boolean isApplicationGenerated() {
            return strategy.isApplicationGenerated() || hasCustomGenerator();
        }

        /**
         * Check if ID is generated by the database.
         */
        boolean isDatabaseGenerated() {
            return strategy.isDatabaseGenerated();
        }

        /**
         * Check if a custom generator is specified.
         */
        boolean hasCustomGenerator() {
            return generatorClass != IdGenerator.None.class;
        }

        /**
         * Check if manual assignment is required.
         */
        boolean isManual() {
            return strategy == GenerationType.NONE && !hasCustomGenerator();
        }
    }

    private EntityReflector() {
        // Utility class
    }

    /**
     * Extract the ID value from an entity.
     * Finds the field annotated with @Id and returns its value.
     *
     * @param entity the entity instance
     * @return the ID value
     * @throws IllegalArgumentException if no @Id field found or cannot access it
     */
    static Object getId(Object entity) {
        if (Objects.isNull(entity)) {
            throw new IllegalArgumentException("Entity cannot be null");
        }

        Class<?> entityClass = entity.getClass();
        Field idField = ID_FIELD_CACHE.computeIfAbsent(entityClass, EntityReflector::findIdField);

        Object value = ReflectionUtils.getFieldValue(entity, idField.getName());
        if (Objects.isNull(value)) {
            throw new IllegalArgumentException("Entity ID cannot be null for class: " + entityClass.getName());
        }
        return value;
    }

    /**
     * Set a field value on an entity by field name (not column name).
     *
     * @param entity the entity instance
     * @param fieldName the Java field name
     * @param value the value to set
     * @throws IllegalArgumentException if field not found or cannot be set
     */
    static void setField(Object entity, String fieldName, Object value) {
        if (Objects.isNull(entity)) {
            throw new IllegalArgumentException("Entity cannot be null");
        }
        if (Objects.isNull(fieldName) || fieldName.isEmpty()) {
            throw new IllegalArgumentException("Field name cannot be null or empty");
        }

        Class<?> entityClass = entity.getClass();
        Map<String, Field> fieldMap = getFieldMap(entityClass);
        Field field = fieldMap.get(fieldName);

        if (Objects.isNull(field)) {
            throw new IllegalArgumentException("Field not found: " + fieldName + " in class: " + entityClass.getName());
        }

        boolean success = ReflectionUtils.setFieldValue(entity, fieldName, value);
        if (!success) {
            throw new IllegalArgumentException("Cannot set field: " + fieldName + " on class: " + entityClass.getName() +
                    ". Add a public setter or disable strict mode.");
        }
    }

    /**
     * Set a field value by column name (database column name).
     *
     * @param entity the entity instance
     * @param columnName the database column name
     * @param value the value to set
     * @throws IllegalArgumentException if field not found or cannot be set
     */
    static void setFieldByColumnName(Object entity, String columnName, Object value) {
        if (Objects.isNull(entity)) {
            throw new IllegalArgumentException("Entity cannot be null");
        }
        if (Objects.isNull(columnName) || columnName.isEmpty()) {
            throw new IllegalArgumentException("Column name cannot be null or empty");
        }

        Class<?> entityClass = entity.getClass();
        Field field = findFieldByColumnName(entityClass, columnName);

        if (Objects.isNull(field)) {
            throw new IllegalArgumentException("No field found for column: " + columnName + " in class: " + entityClass.getName());
        }

        boolean success = ReflectionUtils.setFieldValue(entity, field.getName(), value);
        if (!success) {
            throw new IllegalArgumentException("Cannot set field for column: " + columnName + " on class: " + entityClass.getName() +
                    ". Add a public setter or disable strict mode.");
        }
    }

    /**
     * Convert an entity to a column name -> value map.
     * Only includes fields annotated with @Column.
     *
     * @param entity the entity instance
     * @return map of column names to values (preserves insertion order)
     * @throws IllegalArgumentException if reflection fails
     */
    static Map<String, Object> toColumnMap(Object entity) {
        if (Objects.isNull(entity)) {
            throw new IllegalArgumentException("Entity cannot be null");
        }

        Class<?> entityClass = entity.getClass();
        Map<String, Object> columnMap = new LinkedHashMap<>();

        for (Field field : getAllFields(entityClass)) {
            Column column = field.getAnnotation(Column.class);
            if (Objects.nonNull(column)) {
                Object value = ReflectionUtils.getFieldValue(entity, field.getName());
                if (Objects.nonNull(value)) {
                    // Convert @JsonbColumn fields to PGobject for PostgreSQL JSONB
                    if (field.isAnnotationPresent(JsonbColumn.class)) {
                        value = toJsonbObject(value);
                    }
                    // Convert String to UUID for SqlType.UUID columns
                    if (column.type() == SqlType.UUID && value instanceof String str) {
                        try {
                            value = UUID.fromString(str);
                        } catch (IllegalArgumentException e) {
                            throw new IllegalArgumentException(
                                "Invalid UUID format for column '" + column.name() + "': " + str, e);
                        }
                    }
                    columnMap.put(column.name(), value);
                }
            }
        }

        return columnMap;
    }

    /**
     * Convert a value to PostgreSQL JSONB PGobject.
     * Package-private for use by EntityPersistence.
     */
    static PGobject toJsonbObject(Object value) {
        try {
            PGobject pgObject = new PGobject();
            pgObject.setType("jsonb");
            pgObject.setValue(JSON_MAPPER.writeValueAsString(value));
            return pgObject;
        } catch (Exception e) {
            throw new IllegalArgumentException("Failed to convert value to JSONB: " + value, e);
        }
    }

    /**
     * Get entity metadata (table name, schema, ID column) from annotations.
     * Caches result for performance.
     *
     * @param entityClass the entity class
     * @return entity metadata
     * @throws IllegalArgumentException if class is not a valid entity
     */
    static EntityMeta getEntityMeta(Class<?> entityClass) {
        if (Objects.isNull(entityClass)) {
            throw new IllegalArgumentException("Entity class cannot be null");
        }
        return ENTITY_META_CACHE.computeIfAbsent(entityClass, EntityReflector::extractEntityMeta);
    }

    /**
     * Get ID field metadata including generation strategy.
     * Caches result for performance.
     *
     * @param entityClass the entity class
     * @return ID metadata
     * @throws IllegalArgumentException if class has no @Id field
     */
    static IdMeta getIdMeta(Class<?> entityClass) {
        if (Objects.isNull(entityClass)) {
            throw new IllegalArgumentException("Entity class cannot be null");
        }
        return ID_META_CACHE.computeIfAbsent(entityClass, EntityReflector::extractIdMeta);
    }

    /**
     * Extract ID metadata from @Id annotation.
     */
    private static IdMeta extractIdMeta(Class<?> entityClass) {
        Field idField = findIdField(entityClass);
        Id idAnnotation = idField.getAnnotation(Id.class);

        // Get column name and type
        String columnName;
        SqlType columnType = SqlType.AUTO;
        Column columnAnnotation = idField.getAnnotation(Column.class);
        if (Objects.nonNull(columnAnnotation)) {
            columnName = columnAnnotation.name().isEmpty()
                ? Casey.toSnakeCase(idField.getName())
                : columnAnnotation.name();
            columnType = columnAnnotation.type();
        } else {
            columnName = Casey.toSnakeCase(idField.getName());
        }

        return new IdMeta(
            idField.getName(),
            columnName,
            idField.getType(),
            idAnnotation.strategy(),
            idAnnotation.generator(),
            idAnnotation.sequence(),
            columnType
        );
    }

    /**
     * Get ID value from entity, returning null if not set (instead of throwing).
     *
     * @param entity the entity instance
     * @return the ID value or null
     */
    static Object getIdOrNull(Object entity) {
        if (Objects.isNull(entity)) {
            return null;
        }
        Class<?> entityClass = entity.getClass();
        Field idField = ID_FIELD_CACHE.computeIfAbsent(entityClass, EntityReflector::findIdField);
        return ReflectionUtils.getFieldValue(entity, idField.getName());
    }

    /**
     * Set the ID value on an entity.
     *
     * @param entity the entity instance
     * @param id the ID value to set
     */
    static void setId(Object entity, Object id) {
        if (Objects.isNull(entity)) {
            throw new IllegalArgumentException("Entity cannot be null");
        }
        Class<?> entityClass = entity.getClass();
        Field idField = ID_FIELD_CACHE.computeIfAbsent(entityClass, EntityReflector::findIdField);
        boolean success = ReflectionUtils.setFieldValue(entity, idField.getName(), id);
        if (!success) {
            throw new IllegalArgumentException("Cannot set ID field on entity: " + entityClass.getName());
        }
    }

    /**
     * Extract entity metadata from annotations.
     */
    private static EntityMeta extractEntityMeta(Class<?> entityClass) {
        String tableName = null;
        String schema = null;

        // Check @Entity annotation first (preferred)
        Entity entityAnnotation = entityClass.getAnnotation(Entity.class);
        if (Objects.nonNull(entityAnnotation)) {
            if (!entityAnnotation.table().isEmpty()) {
                tableName = entityAnnotation.table();
            }
            if (!entityAnnotation.schema().isEmpty()) {
                schema = entityAnnotation.schema();
            }
        }

        // Fall back to @Table annotation
        if (Objects.isNull(tableName)) {
            Table tableAnnotation = entityClass.getAnnotation(Table.class);
            if (Objects.nonNull(tableAnnotation)) {
                if (!tableAnnotation.name().isEmpty()) {
                    tableName = tableAnnotation.name();
                }
                if (Objects.isNull(schema) && !tableAnnotation.schema().isEmpty()) {
                    schema = tableAnnotation.schema();
                }
            }
        }

        // Default to snake_case class name if no annotation
        if (Objects.isNull(tableName)) {
            tableName = Casey.toSnakeCase(entityClass.getSimpleName());
        }

        // Get ID column name
        String idColumn = null;
        for (Field field : getAllFields(entityClass)) {
            if (field.isAnnotationPresent(Id.class)) {
                Column columnAnnotation = field.getAnnotation(Column.class);
                if (Objects.nonNull(columnAnnotation) && !columnAnnotation.name().isEmpty()) {
                    idColumn = columnAnnotation.name();
                } else {
                    idColumn = Casey.toSnakeCase(field.getName());
                }
                break;
            }
        }

        if (Objects.isNull(idColumn)) {
            throw new IllegalArgumentException(
                "No @Id field found in class: " + entityClass.getName() +
                ". Entity must have a field annotated with @Id."
            );
        }

        return new EntityMeta(tableName, schema, idColumn);
    }

    /**
     * Find the field annotated with @Id.
     */
    private static Field findIdField(Class<?> entityClass) {
        for (Field field : getAllFields(entityClass)) {
            if (field.isAnnotationPresent(Id.class)) {
                return field;
            }
        }
        throw new IllegalArgumentException("No @Id field found in class: " + entityClass.getName());
    }

    /**
     * Find field by database column name.
     */
    private static Field findFieldByColumnName(Class<?> entityClass, String columnName) {
        for (Field field : getAllFields(entityClass)) {
            Column column = field.getAnnotation(Column.class);
            if (Objects.nonNull(column) && column.name().equalsIgnoreCase(columnName)) {
                return field;
            }
        }
        return null;
    }

    /**
     * Get the SqlType for a column from @Column annotation.
     *
     * @param entityClass the entity class
     * @param columnName  the database column name
     * @return SqlType or AUTO if not found
     */
    static SqlType getColumnType(Class<?> entityClass, String columnName) {
        if (Objects.isNull(entityClass) || Objects.isNull(columnName)) {
            return SqlType.AUTO;
        }

        Field field = findFieldByColumnName(entityClass, columnName);
        if (Objects.isNull(field)) {
            return SqlType.AUTO;
        }

        Column column = field.getAnnotation(Column.class);
        return Objects.nonNull(column) ? column.type() : SqlType.AUTO;
    }

    /**
     * Check if a column is UUID type based on @Column annotation.
     *
     * @param entityClass the entity class
     * @param columnName  the database column name
     * @return true if column is annotated with SqlType.UUID
     */
    static boolean isUuidColumn(Class<?> entityClass, String columnName) {
        return getColumnType(entityClass, columnName) == SqlType.UUID;
    }

    /**
     * Get field value by column name (database column name).
     *
     * @param entity     the entity instance
     * @param columnName the database column name
     * @return the field value, or null if not found
     */
    static Object getFieldByColumnName(Object entity, String columnName) {
        if (Objects.isNull(entity)) {
            return null;
        }
        if (Objects.isNull(columnName) || columnName.isEmpty()) {
            return null;
        }

        Class<?> entityClass = entity.getClass();
        Field field = findFieldByColumnName(entityClass, columnName);

        if (Objects.isNull(field)) {
            return null;
        }

        return ReflectionUtils.getFieldValue(entity, field.getName());
    }

    /**
     * Get all fields for a class (including inherited fields).
     */
    private static Field[] getAllFields(Class<?> clazz) {
        List<Field> fields = new ArrayList<>();
        Class<?> current = clazz;
        while (Objects.nonNull(current) && current != Object.class) {
            fields.addAll(Arrays.asList(current.getDeclaredFields()));
            current = current.getSuperclass();
        }
        return fields.toArray(new Field[0]);
    }

    /**
     * Build and cache field map for a class.
     */
    private static Map<String, Field> getFieldMap(Class<?> entityClass) {
        return FIELD_CACHE.computeIfAbsent(entityClass, clazz -> {
            Map<String, Field> map = new LinkedHashMap<>();
            for (Field field : getAllFields(clazz)) {
                map.put(field.getName(), field);
            }
            return map;
        });
    }

    /**
     * Create an entity instance from a map of column names to values.
     * Only sets fields that have corresponding entries in the attribute map.
     *
     * @param entityClass the entity class to instantiate
     * @param attributes map of column names to values
     * @param <T> entity type
     * @return new entity instance with fields set from the map
     * @throws IllegalArgumentException if entity cannot be instantiated or fields cannot be set
     */
    static <T> T fromMap(Class<T> entityClass, Map<String, Object> attributes) {
        if (Objects.isNull(entityClass)) {
            throw new IllegalArgumentException("Entity class cannot be null");
        }
        if (Objects.isNull(attributes)) {
            throw new IllegalArgumentException("Attributes map cannot be null");
        }

        // Create new instance
        T entity;
        try {
            entity = entityClass.getDeclaredConstructor().newInstance();
        } catch (Exception e) {
            throw new IllegalArgumentException("Cannot instantiate entity class: " + entityClass.getName() +
                ". Ensure it has a no-arg constructor.", e);
        }

        // Set fields from attribute map
        for (Map.Entry<String, Object> entry : attributes.entrySet()) {
            String columnName = entry.getKey();
            Object value = entry.getValue();

            Field field = findFieldByColumnName(entityClass, columnName);
            if (Objects.nonNull(field)) {
                boolean success = ReflectionUtils.setFieldValue(entity, field.getName(), value);
                if (!success && ReflectionUtils.isStrictMode()) {
                    throw new IllegalArgumentException("Cannot set field for column: " + columnName +
                        " on class: " + entityClass.getName() + ". Add a public setter.");
                }
            }
        }

        return entity;
    }
}
